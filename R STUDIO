using PCAdapt
https://cran.r-project.org/web/packages/pcadapt/vignettes/pcadapt.html

install.packages("pcadapt")
library(pcadapt)

#reading the genotype data: converting it into the BED format#
path_to_file <-"/Users/bobbiecattani/Birds/vcftools/filename.final.recode.vcf"
filename <- read.pcadapt(path_to_file, type = "vcf")

#The pcadapt function performs two successive tasks. First, PCA is performed on the centered and scaled genotype matrix. The second stage consists in computing test statistics and p-values based on the correlations between SNPs and the first K principal components (PCs). To run the function pcadapt, the user should specify the output returned by the function read.pcadapt and the number K of principal components to compute. To choose K, principal component analysis should first be performed with a large enough number of principal components (e.g. K=20).#
x <- pcadapt(input = filename, K = 20) 
#NB: by default, data are assumed to be diploid. To specify the ploidy, use the argument ploidy (ploidy=2 for diploid species and ploidy = 1 for haploid species) in the pcadapt function.#
#The ‘scree plot’ displays in decreasing order the percentage of variance explained by each PC. Up to a constant, it corresponds to the eigenvalues in decreasing order. The ideal pattern in a scree plot is a steep curve followed by a bend and a straight line. The eigenvalues that correspond to random variation lie on a straight line whereas the ones that correspond to population structure lie on a steep curve. We recommend to keep PCs that correspond to eigenvalues to the left of the straight line (Cattell’s rule). In the provided example, K = 2 is the optimal choice for K. The plot function displays a scree plot:#
plot(x, option = "screeplot")

#By default, the number of principal components shown in the scree plot is K, but it can be reduced via the argument K.#

plot(x, option = "screeplot", K = 10)

#probably use the first 5 or 3 - as long as you capture most of the variance as ok#, we;d expect 1-3 to explain variance between sp + the rest within: they become relevant the more complex analysis you get#

#IMPORT  table data: #
 
 poplist.csv <- read.csv("/Users/bobbiecattani/Birds/pheasantpops.csv", header=TRUE)
head(poplist.csv)
poplist.names <-poplist.csv[,7]
str(poplist.names)
plot(x, option = "scores", pop = poplist.names)
                    
  ##make sure you use cSV to read in - didn't work properly with importing the excel file. 
  
  
  
  See what scores + loadings mean. 
 . sumary (x)
 K = number of principle components. 
 scores            1280 -none- numeric - scores is a (n,K) matrix corresponding to the projections of the individuals onto each PC.
singular.values     20 -none- numeric - vector containing the K ordered squared root of the proportion of variance explained by each PC.
loadings        830060 -none- numeric - a (L,K) matrix containing the correlations between each genetic marker and each PC.
zscores         830060 -none- numeric - a (L,K) matrix containing the z-scores.
af               41503 -none- numeric - a vector of size L containing allele frequencies of derived alleles where genotypes of 0 are supposed to code for homozygous for the reference allele.
maf              41503 -none- numeric   - a vector of size L containing minor allele frequencies
chi2.stat        41503 -none- numeric - . a vector of size L containing the rescaled statistics stat/gif that follow a chi-squared distribution with K degrees of freedom.
stat             41503 -none- numeric - a vector of size L containing squared Mahalanobis distances by default
gif                  1 -none- numeric - is a numerical value corresponding to the genomic inflation factor estimated from stat.
pvalues          41503 -none- numeric - a vector containing L p-values.
pass             40992 -none- numeric - A list of SNPs indices that are kept after exclusion based on the minor allele frequency threshold.
                    
                    
                    
                    
                    
                    #trying it again with the thin filter thing #
path_to_file <-"/Users/bobbiecattani/Birds/vcftools/thinfilter.recode.vcf"
filename2 <- read.pcadapt(path_to_file, type = "vcf")
z <- pcadapt(input = filename2, K = 20) 
#NB: by default, data are assumed to be diploid. To specify the ploidy, use the argument ploidy (ploidy=2 for diploid species and ploidy = 1 for haploid species) in the pcadapt function.#
#The ‘scree plot’ displays in decreasing order the percentage of variance explained by each PC. Up to a constant, it corresponds to the eigenvalues in decreasing order. The ideal pattern in a scree plot is a steep curve followed by a bend and a straight line. The eigenvalues that correspond to random variation lie on a straight line whereas the ones that correspond to population structure lie on a steep curve. We recommend to keep PCs that correspond to eigenvalues to the left of the straight line (Cattell’s rule). In the provided example, K = 2 is the optimal choice for K. The plot function displays a scree plot:#
plot(z, option = "screeplot")
poplist.csv <- read.csv("/Users/bobbiecattani/Birds/speciespheasant.csv", header=TRUE)
poplist.names <-poplist.csv[,7]
plot(z, option = "scores", pop = poplist.names)

##ADEGENET#


For adegenet the easiest might be to read the file in from structure format. I've converted your vcf file to structure using pgdspider. Attached is the input file. 

Use the code below to read it in. This should create a genind object which you can run the adegenet commands on. 


file <- read.structure("finalname.final.recode.str")

 How many genotypes are there? 64

 How many markers are there? 41503

 Which column contains labels for genotypes ('0' if absent)? 1

 Which column contains the population factor ('0' if absent)? 2

 Which other optional columns should be read (press 'return' when done)? 1: 

 Which row contains the marker names ('0' if absent)? 1

 Are genotypes coded by a single row (y/n)? n

 Converting data from a STRUCTURE .stru file to a genind object..



birds <- read.structure("/Users/aminachabach/Project/finalname.final.recode.str")
#type number in the console bit: Output = (btw toook absolutely ages to load???)

#/// GENIND OBJECT /////////

#// 64 individuals; 41,503 loci; 83,436 alleles; size: 42.4 Mb

#// Basic content
#@tab:  64 x 83436 matrix of allele counts
#@loc.n.all: number of alleles per locus (range: 2-4)
#@loc.fac: locus factor for the 83436 columns of @tab
#@all.names: list of allele names for each locus
#@ploidy: ploidy of each individual  (range: 2-2)
#@type:  codom
#@call: read.structure(file = "/Users/aminachabach/Project/finalname.final.recode.str")

#// Optional content
#@pop: population of each individual (group size range: 2-22)
data(birds)
#still doesn't work btw

phepop <- genind2genpop(birds)
phepop
#As in genind objects, data are stored as numbers of alleles, but this time for populations #(here, phe colonies): 5 rows & 10 colums

phepop$tab[1:5,1:10]
3.3 Using accessors

#One advantage of formal (S4) classes is that they allow for interacting simply with possibly complex objects. This is made possible by using accessors, i.e. functions that extract information from an object, rather than accessing the slots directly. Another advantage of this approach is that as long as accessors remain identical on the user’s side, the internal structure of an object may change from one release to another without generating errors in old scripts. Although genind and genpop objects are fairly simple, we recommend using accessors whenever possible to access or modify their content.

(#nancycats=birds in my code)

#indNames†: returns/sets labels for individuals; only for genind.

head(indNames(file),10)
#nInd: returns the number of individuals in the object; only for genind. #DONT'T RUN OUR NAMES ARE FINE AS THEY ARE

indNames(birds) <- paste("cat", 1:nInd(birds),sep=".")
head(indNames(birds),10)
#locNames: returns/sets labels for l

locNames(birds)
#returns the names of the alleles in the form ’loci.allele’.

temp <- locNames(birds, withAlleles=TRUE)
head(temp, 10)
#The slot ’pop’ can be retrieved and set using pop:

obj <- birds[sample(1:50,10)]
pop(obj)
# [1] 2 1 5 1 2 2 3 2 1 1
#Levels: 1 2 3 5

pop(obj) <- rep("newPop",10)
pop(obj)
#Accessors make things easier. For instance, when setting new names for loci, the columns #of @tab are renamed automatically:

head(colnames(tab(obj)),20)

locNames(obj)

locNames(obj)[1] <- "newLocusName"
locNames(obj)

head(colnames(tab(obj)),20)

obj@pop <- rep("newPop",10)
5.4 Measuring and testing population structure (a.k.a F statistics)

library(devtools)
install_github("jgx65/hierfstat")
#Haven't actually installed this, do we even need it bc the net line runs?

#Can we find any population structure in the pheasent colonies? The basic F statistics are provided by:

library("hierfstat")
fstat(birds)
#This table provides the three F statistics F st (pop/total), F it (Ind/total), and F is #(ind/pop). These are overall measures which take into account all genotypes and all loci. #For more detail, pegas provides estimates by locus:

#This table provides the three F statistics F st (pop/total), F it (Ind/total), and F is #(ind/pop). These are overall measures which take into account all genotypes and all loci.

	pop       Ind
Total 0.7958457 0.8203680
pop   0.0000000 0.1201165
#SO: FST = 0.7958457; FIT = 0.8203680; FIS = 0.1201165

#The measures FIS, FST, and FIT are related to the amounts of heterozygosity at various levels of population structure. Together, they are called F-statistics, and are derived from F, the inbreeding coefficient.

#FIT is the inbreeding coefficient of an individual (I) relative to the total (T) population, as above; FIS is the inbreeding coefficient of an individual (I) relative to the subpopulation (S)*, using the above for subpopulations and averaging them; and FST is the effect of subpopulations (S) compared to the total population (T)

#The fixation index (FST) is a measure of population differentiation due to genetic structure. It is frequently estimated from genetic polymorphism data, such as single-nucleotide polymorphisms (SNP) or microsatellites. Developed as a special case of Wright's F-statistics, it is one of the most commonly used statistics in population genetics.

#For more detail, pegas provides estimates by locus:

library(pegas)
Fst(as.loci(birds))
